/*              --- ПРИНЦИП РАБОТЫ ---
 *   Для нахождения расстояния по Левенштейну(Ld) используется
 * двумерная динамика. В двумерном массиве dp хранятся расстояния для
 * пар префиксов.
 *   Для каждого символа одной строки мы итерируемся
 * по всем символам другой, записывая таким образом расстояния для пар
 * префиксов. Базовые случаи - одна пустая строка и все префиксы
 * второй и точно также наоборот. Таким образом формируется первичная
 * матрица расстояний.
 *   Динамика перехода предполагает выбор из трёх пар префиксов одной
 * с наименьшим расстоянием и добавление к ней стоимости осуществления
 * операции (если выбирается пара, предполагающая замену символа, то
 * стоимость операции добавляется только в том случае, если замена
 * необходима). В итоге результат будет находиться в последней ячейке
 * массива.
 *   Так как для достижения цели задачи достаточно хранить
 * обрабатываемую строку массива и предыдущую, вся матрица не
 * хранится. Базовый случай для одной из строк изначально записывается
 * во вторую строку массива, а для другой из сравниваемых строк
 * базовый случай эмулируется номером итерации, который записывается в
 * первую ячейку обрабатываемой строки массива.
 *
 *              --- ВРЕМЕННАЯ СЛОЖНОСТЬ ---
 *   Каждая ячейка условной матрицы размером N*M (где N - длина первой
 * строки, M - длина второй строки) посещается и считается один раз,
 * формируя таким образом сложность по времени O(N*M).
 *
 *              --- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ ---
 *   Так как вместо полной матрицы в реализованном алгоритме
 * используется только 2 строки, в худшем случае, пространственная
 * сложность составит O(n), где n - длина более длинной строки.
 *
 */

#include <iostream>
#include <vector>
#include <algorithm>
#include <string>

int get_distance(const std::string& s1, const std::string& s2)
{
    std::vector<std::vector<int>> dp(2, std::vector<int>(s2.size()+1, 0));

    for (unsigned int i = 1; i < dp[1].size(); ++i)
        dp[1][i] = i;

    for (unsigned int i = 1; i < s1.size()+1; ++i) {
        std::swap(dp[0], dp[1]);
        dp[1][0] = i;
        for (unsigned int j = 1; j < dp[1].size(); ++j) {
            dp[1][j] = std::min(dp[1][j-1] + 1,
                       std::min(dp[0][j] + 1,
                                dp[0][j-1] + (s1[i-1] != s2[j-1])));
        }
    }

    return dp[1][s2.size()];
}

int main()
{
    std::string s1;
    std::string s2;
    std::cin >> s1 >> s2;

    std::cout << get_distance(s1, s2) << std::endl;

    return 0;
}
